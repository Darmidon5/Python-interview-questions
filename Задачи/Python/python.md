1) # TODO: complete this class

class PaginationHelper:
    
    # The constructor takes in an array of items and an integer indicating
    # how many items fit within a single page
    def init(self, collection, items_per_page):
        pass
    
    # returns the number of items within the entire collection
    def item_count(self):
        pass
    
    # returns the number of pages
    def page_count(self):
        pass
    
    # returns the number of items on the given page. page_index is zero based
    # this method should return -1 for page_index values that are out of range
    def page_item_count(self, page_index):
        pass
    
    # determines what page an item at the given index is on. Zero based indexes.
    # this method should return -1 for item_index values that are out of range
    def page_index(self, item_index):
        pass
For this exercise you will be strengthening your page-fu mastery. You will complete the PaginationHelper class, which is a utility class helpful for querying paging information related to an array.

The class is designed to take in an array of values and an integer indicating how many items will be allowed per each page. The types of values contained within the collection/array are not relevant.

The following are some examples of how this class is used:

helper = PaginationHelper(['a','b','c','d','e','f'], 4)
helper.page_count() # should == 2
helper.item_count() # should == 6
helper.page_item_count(0) # should == 4
helper.page_item_count(1) # last page - should == 2
helper.page_item_count(2) # should == -1 since the page is invalid

# page_index takes an item index and returns the page that it belongs on
helper.page_index(5) # should == 1 (zero based index)
helper.page_index(2) # should == 0
helper.page_index(20) # should == -1
helper.page_index(-10) # should == -1 because negative indexes are invalid
—------------------------------------------------------------------------------------------------------------------------

2) что выведет
my_list = [‘a’, ‘b’]
print(my_list[3:])
—------------------------------------------------------------------------------------------------------------------------

3) как это отработает и что выведется на экран
import asyncio

async def function():
  await asyncio.sleep(10)
  print("World!")

async def main():
  await function()
  print("Hello!")

if name == "main":
  asyncio.run(main())

—------------------------------------------------------------------------------------------------------------------------

4) def func(a = [ ]):
    a.append(1)
    return a

print(func())
print(func())
print(func())

какой будет вывод к этого кода

—------------------------------------------------------------------------------------------------------------------------

5) class A:
  def init(self):
    print("A")

class B:
  def init(self):
    print("B")

class C(A,B):
  def init(self):
    print("C")

какой будет вывод у этого кода

—------------------------------------------------------------------------------------------------------------------------

 6) напишите декоратор классов

—------------------------------------------------------------------------------------------------------------------------

7) функция принимает два словаря, сделать flatten представление каждого, вывести разницу.

—------------------------------------------------------------------------------------------------------------------------

8) задача - найти sql-инъекцию в сыром запросе

—------------------------------------------------------------------------------------------------------------------------

9) принять dict, вернуть dict, но где местами поменяли ключи и значения

—------------------------------------------------------------------------------------------------------------------------

10) реализовать декоратор, выводящий сообщения о начале и конце перед функцией и после нее

—------------------------------------------------------------------------------------------------------------------------

11) параметризованный декоратор

—------------------------------------------------------------------------------------------------------------------------

12) Написать декоратор считает время выполнения функции. **

—------------------------------------------------------------------------------------------------------------------------

13) Написать функцию которая принимает путь к файлу, открывает его на чтение и возврашает (True, данные), если произошла ошибка, возврашает (False, None)

—------------------------------------------------------------------------------------------------------------------------
14) Есть сервис (какая-то имплементация внутри объекта generator),
который обрабатывает некие сетевые пакеты, представим их в виде 
положительных чисел. При этом пакеты, из-за перемешивания могут
приходить как раньше <= 5 штук, так и опаздывать <= 5 штук.
Нам необходимо написать функцию, которая будет выдавать нам
полученные числа в отсортированном порядке.

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
1 2 3 4 10 5 6 7 8 9 11 12 13 14 15 - такая последовательность допустима
1 10 2 3 4 6 7 8 9 11 12 13 14 15 - такая последовательность не может 
прийти, десятка больше чем на пять позиций опередила свое место

# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

def sorted_generator(generator): pass

—------------------------------------------------------------------------------------------------------------------------

15) # Дано описание структуры узла бинарного дерева
# Необходимо написать функцию, которая принимает на вход корень дерева и возвращает сумму значений всех 
# его левых листьев

# Дерево
#      1
#     /  \
#   2      3
#  / \    /  \
# 4   5  9    8
#           /  \
#           6    7

# Ответ: 4 + 9 + 6 = 19
class Node:
    def init(self, val: int = 0, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right
       
root = Node(
    val=1,
    left=Node(
        val=2,
        left=Node(val=4),
        right=Node(val=5),
    ),
    right=Node(
        val=3,
        left=Node(val=9),
        right=Node(
            val=8,
            left=Node(val=6),
            right=Node(val=7),
        ),
    ),
)

def sum_of_left_leaves(root: Node) -> int:
     pass
—------------------------------------------------------------------------------------------------------------------------
16) написать декоратор для кэширования функции с настраиваемым ttl для кэша

—------------------------------------------------------------------------------------------------------------------------

17) отдебажить
import functools


class MyMeta(type):
    def __new__(cls, name, bases, dct):
        for name, func in list(dct.items()):
            if callable(func): 
                @functools.wraps(func)
                def wrapper(*args, **kwargs):
                   try:                        
                        return func(*args, **kwargs)
                   finally:
                        print(f'Called {name}')
                dct[name] = wrapper
        return type.__new__(cls, name, bases, dct)
    
class A(metaclass=MyMeta):

    def foo(self, n):
        return f'foo{n}'

    def bar(self, n):
        return f'bar{n}'

a = A()
print(a.foo(1) + a.bar(2))

—------------------------------------------------------------------------------------------------------------------------
18) Написать функцию, которая определяет, является ли строка палиндромом
—------------------------------------------------------------------------------------------------------------------------
19) оптимизировать
import random
 
def foo(i: int) -> str:
    if random.randrange(3) > 0:
        raise Exception(f'oops {i}')
    return f"magic result {i}"
 
def call():
    '''call foo 5 times with i =0,1,2,.... First success should print the result otherwise raise Exception.'''
    try:
        print(foo(0))
    except Exception:
        try:
            print(foo(1))
        except Exception:
            try:
                print(foo(2))
            except Exception:
                try:
                    print(foo(3))
                except Exception:
                    try:
                        print(foo(4))
                    except Exception:
                        raise Exception("error") from None
—------------------------------------------------------------------------------------------------------------------------
20) переопределить == для класса так, чтобы его можно было сравнивать по аргументам с такими же классами
class Car:
    def __init__(self, wheels, brake):
        self.wheels = wheels
        self.brake = brake
—------------------------------------------------------------------------------------------------------------------------
21) написать функцию, сортирующую только нечетные числа в списке, четные должны остаться на своих местах
—------------------------------------------------------------------------------------------------------------------------
22) Написать функцию add, которая принимает число и может вызываться бесконечное число раз, пока не будет вызвана без аргументов - тогда возвращается сумма переданных ранее чисел
print( add(8)(9)(10)() ); # 27
—------------------------------------------------------------------------------------------------------------------------
23)
import time
import asyncio


async def foo(i: int):
    time.sleep(2)
    return i

tasks = [foo(i) for i in range(0, 5)]

# выполнять таски паралельно и распечатать их 

—------------------------------------------------------------------------------------------------------------------------
24) Дана последовательность чисел. Нужно её схлопнуть в строку.
Пример: [6,1,2,3, 7,0] - > "0-3, 6-7". Числа неотрицательные. 
—------------------------------------------------------------------------------------------------------------------------
25) Дано множество точек на декартовой плоскости. Необходимо найти такую вертикальную прямую, что все точки относительно неё будут симметричны. То есть есть прямая, а относительно неё n точек слева и n справа. Точки, попавшие на прямую считаются симметричными относительно себя.
—------------------------------------------------------------------------------------------------------------------------
26) Дана строка из символов XYO, надо вывести кратчайшее расстояние между символами X и Y.
Даны примеры, и даже краевые случаи (нет иксов, нет игреков, разный порядок иксов и игреков).
—------------------------------------------------------------------------------------------------------------------------
27) Даны две строки: T и S, надо найти первое вхождение S в T БЕЗ учёта порядка символов. Пример  T=reebok S=bee, ответ i=1 (eeb содержит те же символы что и bee).
—------------------------------------------------------------------------------------------------------------------------
28) Реализовать структуру МУЛЬТИмножество КОТОРАЯ за О(1) вернёт ЛЮБОЙ элемент из тех, что в МУЛЬТИмножестве представлены единственный раз
методы add, delete, get_unique.
—------------------------------------------------------------------------------------------------------------------------
29)   def foo(bar=[]):
      bar.append(1)
	  return bar
Что выдаст foo(), foo(), foo()
—------------------------------------------------------------------------------------------------------------------------

30) Требуется реализовать функцию uniqRandn, которая генерирует массив длины n уникальных, рандомных чисел.

—------------------------------------------------------------------------------------------------------------------------

31) Требуется реализовать функцию zip, которая соединяет элементы двух массив в слайс пар
Реализовать версию функции zip которая сможет соединять произвольное количество слайсов

—------------------------------------------------------------------------------------------------------------------------

32) У нас есть база данных с паролями пользователей, пароли захешированы (функция hashPassword),
а так же известен набор символов которые могут быть использованы в паролях (переменная alphabet).
Наша задача реализовать функцию RecoverPassword так, чтобы она восстанавливала пароль по известному хэшу
и TestRecoverPassword завершился успешно

alphabet = ['a', 'b', 'c', 'd', '1', '2', '3']

def generate_combinations(alphabet, iteration, prev_combinations):
 	if prev_combinations:
    	result = []
    	for combo in prev_combinations:
        	for letter in alphabet:
            	result.append(combo + letter)
    	return result
	return alphabet

def recoverPassword(hash_pass: str) -> str:
	pass

func TestRecoverPassword(t *testing.T) {
	for _, exp := range []string{
    	"a",
    	"12",
    	"abc333d",
	} {
    	t.Run(exp, func(t *testing.T) {
        	act := RecoverPassword(hashPassword(exp))
        	if act != exp {
            	t.Error("recovered:", act, "expected:", exp)
        	}
    	})
	}
}

func hashPassword(in string) []byte {
	h := md5.Sum([]byte(in))
	return h[:]
}

—------------------------------------------------------------------------------------------------------------------------

33) 
"""
Есть коллекции именованных кортежей User и Group.
Хочется написать функции для объединения их в новый список типа UserGroup
по аналогии с LEFT/RIGHT JOIN из стандарта SQL.


User
+------+----------+
|  id  | group_id |
+------+----------+
| 1    |    1     |
| 2    |    2     |
| 3    |    2     |
+------+----------+

Group
+-------+------+
|  id   | name |
+-------+------+
| 1     | G1   |
| 2     | G2   |
| 3     | G3   |
+-------+-------+

LEFT JOIN - UserGroup
+---------+----------+------------+
| user_id | group_id | group_name |
+---------+----------+------------+
|    1    |    1     |    G1      |
|    2    |    2     |    G2      |
|    3    |    2     |    G2      |
+---------+----------+------------+
"""

from dataclasses import dataclass
from typing import Optional


@dataclass
class User:
    id: int
    group_id: Optional[int]


@dataclass
class Group:
    id: int
    name: str


@dataclass
class UserGroup:
    user_id: int
    group_id: Optional[int]
    group_name: Optional[str]


def left_join(users: list[User], groups: list[Group]) -> list[UserGroup]:
    """Возвращает результат: users LEFT JOIN groups"""


дополнительно - покрыть тестами

—------------------------------------------------------------------------------------------------------------------------

34) """
 Нужно написать функцию, которая на вход принимает две строки, и выдаёт
 список слов из первой строки, префиксом которых является вторая строка
 Например
 Вход: "ab abc def abc xyz ace ab", "ab"
 Выход: ["ab", "abc", "abc", "ab"]
 """

 def is_isubstring(str1: str, str2: str) -> list[str]:

—------------------------------------------------------------------------------------------------------------------------

35) Реализовать электронную очередь. Клиенты делятся на VIP и non-VIP. Когда обычный клиент добавляется в очередь, он попадает в ее конец. Когда VIP клиент попадает в очередь, то он встает в ее середину (после клиента в середине, если клиентов в очереди до этого было нечетное количество). Реализовать методы: add(id, vip) – добавляет клиента в очередь, id – идентификатор клиента, vip – его статус. get() – возвращает id первого клиента, удаляет его из очереди. если клиентов нет, то возвращает null.

—------------------------------------------------------------------------------------------------------------------------
